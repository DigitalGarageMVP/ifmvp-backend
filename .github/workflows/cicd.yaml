name: Email Service CI/CD Pipeline

on:
  push:
    branches:
      - k8s
    paths-ignore:
      - '**.md'
      - '.github/**'
      - '!.github/workflows/cicd.yaml'

jobs:
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    outputs:
      timestamp: ${{ steps.set-timestamp.outputs.timestamp }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set timestamp for image tag
        id: set-timestamp
        run: echo "timestamp=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_OUTPUT

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'adopt'
          cache: 'gradle'

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2

      - name: Build with Gradle
        run: |
          chmod +x gradlew
          ./gradlew :auth:build :email:build -x test

      - name: Test with Gradle
        run: |
          ./gradlew :auth:test :auth:jacocoTestReport
          ./gradlew :email:test :email:jacocoTestReport

      - name: SonarQube Analysis
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          ./gradlew :auth:sonar \
            -Dsonar.projectKey=email-auth \
            -Dsonar.projectName=email-auth \
            -Dsonar.host.url=$SONAR_HOST_URL \
            -Dsonar.token=$SONAR_TOKEN \
            -Dsonar.java.binaries=build/classes/java/main \
            -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
            -Dsonar.exclusions=**/config/**,**/entity/**,**/dto/**,**/*Application.class,**/exception/**
          
          ./gradlew :email:sonar \
            -Dsonar.projectKey=email-email \
            -Dsonar.projectName=email-email \
            -Dsonar.host.url=$SONAR_HOST_URL \
            -Dsonar.token=$SONAR_TOKEN \
            -Dsonar.java.binaries=build/classes/java/main \
            -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
            -Dsonar.exclusions=**/config/**,**/entity/**,**/dto/**,**/*Application.class,**/exception/**

      - name: Upload Auth Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: auth-artifacts
          path: auth/build/libs/auth-service.jar
          retention-days: 1

      - name: Upload Email Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: email-artifacts
          path: email/build/libs/email.jar
          retention-days: 1

  release:
    name: Build and Push Docker Images
    needs: build
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ needs.build.outputs.timestamp }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Auth Artifacts
        uses: actions/download-artifact@v4
        with:
          name: auth-artifacts
          path: auth/build/libs/

      - name: Download Email Artifacts
        uses: actions/download-artifact@v4
        with:
          name: email-artifacts
          path: email/build/libs/

      - name: Login to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_USERNAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Read Configuration
        id: config
        run: |
          # Parse configuration from deployment/deploy_env_vars
          registry=$(grep "^registry=" deployment/deploy_env_vars | cut -d '=' -f 2)
          image_org=$(grep "^image_org=" deployment/deploy_env_vars | cut -d '=' -f 2)
          echo "registry=$registry" >> $GITHUB_ENV
          echo "image_org=$image_org" >> $GITHUB_ENV

      - name: Build and Push Auth Image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          file: deployment/Dockerfile
          build-args: |
            BUILD_LIB_DIR=auth/build/libs
            ARTIFACTORY_FILE=auth-service.jar
          tags: ${{ env.registry }}/${{ env.image_org }}/auth:${{ needs.build.outputs.timestamp }}

      - name: Build and Push Email Image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          file: deployment/Dockerfile
          build-args: |
            BUILD_LIB_DIR=email/build/libs
            ARTIFACTORY_FILE=email.jar
          tags: ${{ env.registry }}/${{ env.image_org }}/email:${{ needs.build.outputs.timestamp }}

  deploy:
    name: Deploy to Kubernetes
    needs: [build, release]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Kubernetes Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ictcoe-edu
          cluster-name: ifmvp-aks

      - name: Create Namespace if not exists
        run: |
          kubectl create namespace if-ifmvp-ns --dry-run=client -o yaml | kubectl apply -f -

      - name: Read Configuration
        id: config
        run: |
          # Parse configuration from deployment/deploy_env_vars
          while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments
            [[ $line =~ ^#.* ]] && continue
            [[ -z "$line" ]] && continue
          
            # Extract key-value pairs
            key=$(echo "$line" | cut -d '=' -f 1)
            value=$(echo "$line" | cut -d '=' -f 2-)
          
            # Export as environment variables
            echo "$key=$value" >> $GITHUB_ENV
          done < deployment/deploy_env_vars

      - name: Set Image Tag Environment Variable
        run: |
          echo "image_tag=${{ needs.build.outputs.timestamp }}" >> $GITHUB_ENV

      - name: Generate Kubernetes Manifests
        run: |
          export namespace=$namespace
          export allowed_origins=$allowed_origins
          export jwt_secret_key=$jwt_secret_key
          export postgres_user=$postgres_user
          export postgres_password=$postgres_password
          export mongodb_user=$mongodb_user
          export mongodb_password=$mongodb_password
          export azure_servicebus_connection_string=$azure_servicebus_connection_string
          export azure_storage_connection_string=$azure_storage_connection_string
          export replicas=$replicas
          export resources_requests_cpu=$resources_requests_cpu
          export resources_requests_memory=$resources_requests_memory
          export resources_limits_cpu=$resources_limits_cpu
          export resources_limits_memory=$resources_limits_memory
          
          # Set image paths with timestamp tag
          export auth_image_path=${registry}/${image_org}/auth:${image_tag}
          export email_image_path=${registry}/${image_org}/email:${image_tag}
          
          # Generate manifest from template
          envsubst < deployment/deploy.yaml.template > deployment/deploy.yaml
          
          # Output generated manifest for debugging
          echo "Generated Kubernetes manifest:"
          cat deployment/deploy.yaml

      - name: Apply Kubernetes Manifests
        run: |
          kubectl apply -f deployment/deploy.yaml

      - name: Wait for Deployments to be Available
        run: |
          kubectl -n $namespace wait --for=condition=available deployment/auth --timeout=300s
          kubectl -n $namespace wait --for=condition=available deployment/email --timeout=300s